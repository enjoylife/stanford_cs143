README file for Programming Assignment 2 (Java edition)
=======================================================

Your directory should now contain the following files:

 Makefil
 README
 cool.cup
 lexer                          link to reference lexer
 myparser                       wrapper to run lexer and your parser
 mycoolc                        wrapper to run coolc with your parser
 tests/bad.cl                   \ sample tests
 tests/good.cl                  /
 src/*.java                     \ support code

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.cup is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the CUP documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
        probably add additional tests to the tests/ directory.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).  From
	this file, cool-tree.java is automatically generated by a
	utility that compiles the specification into Java classes for
	constructing tree nodes.  This file is provided for your
	reference.  DO NOT MODIFY.

        TreeNode.java and ListNode.java contain definitions used by the
        tree package. DO NOT MODIFY.  

        Parser.java contains a driver to test the parser. DO NOT MODIFY.

	Flags.java implements routines for parsing command line
	flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `CUP', or
        are internal parser support files.  DO NOT MODIFY.
        `CoolParser.java' is the generated Java file containing the
        parser.  DO NOT MODIFY this file directly; instead, edit
        cool.cup and this file will be regenerated automatically.

	Files not discussed are covered in the README for PA3J.

Instructions
------------

	To compile your parser program type:

	% make parser

	This compiles all the classes and produces an shell script named
	"parser" which invokes Parser.main() as the standalone phase of
	the Cool compiler.  It requires lexer, semant, and cgen to do
	anything useful.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% ./mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	To turnin your work type:

	% make submit

	Running "submit" will collect the files cool.cup, good.cl, bad.cl,
	good.output, bad.output, and README. Don't forget to edit the
	README file to include your write-up, and to write your own test
	cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2J
-----------------
Rules:
Each rule has been translated from the COOL syntax specified in the Reference Manual. Rules for expression non terminal
are branched off for 3 special cases (case statement, let statement and block expressions) as these are specific to
each case. Ex: Let statement has a separate non terminal called let_expr that allows different combinations of valid
let bindings.
Repeated components such as multiple expressions, multiple formals, features etc. are captured by separate
non-terminals such as feature_list, formal_list, expr_list, multiple_expr and case_list to make the grammar cleaner
and easier.

Precedence declarations:
These are also adapted from the Reference Manual. They define the precedence on the arithmetic
and logical operators as supported in COOL. A test for the non associativity of LE, LT and EQ has been added to the
tests directory. (Please see the list below for explanation of each test case)

Shift-Reduce Conflicts:
Initially the rules for feature_list non-terminal produced shift-reduce conflicts as follows:
feature_list
    ::= feature:f
        {: RESULT = (new Features(curr_lineno()).appendElement(f)); :}
    | feature_list:fl feature:f
        {: RESULT = fl.appendElement(f); :}
    |   {: RESULT = new Features(curr_lineno()); :}
The shift-reduce conflict was created due to the first rule which introduced ambiguity to the grammar. Removal of this
rule does not compromise the input strings supported by the grammar as the last rule takes care of the first feature and
the second rule takes care of all the further multiple added features.

Error Handling:
Class - The errors in a class definition are handled/recovered from using SEMI as the synchronising token. Hence the
parser continues to parse the rest of the file and reports the error in the class definition. The erroneous class
definition is expected to be terminated appropriately for the parser to recover.
Errors in class definitions such as typos in class or inherits will cause the parser to ignore the entire erroneous
class.

Feature - Similar to the class error handling, the feature non-terminal has an additional error rule. The synchronising
token(SEMI) is added in the feature_list rule.
ex: feature_list
        ::= feature_list:fl feature:f SEMI
   feature
        ::= error
Again, as in the case of class error handling, the erroneous feature is expected to be terminated appropriately in order
to recover the parser. Any error in feature will cause the parser to move on to the next feature.

Block - Similar to the earlier error handling, expressions within blocks are reported and recovered from if the are
terminated by a SEMI(semicolon). The multiple_expr rules have 2 error rules: multiple_expr error SEMI and error SEMI.
This allows blocks containing expressions in the form : bad_syntax, good_syntax, bad_syntax can be caught appropriately.

Let Expression - The let expression has 2 error rules, error COMMA let_expr and error IN expr. The former rule is to
recover from errors within a let expression with multiple bindings. If one binding has an error, this rule helps recover
and parse the next binding. The latter rule is for error in a single binding let expression.

-- Test Cases
- Negative test cases
test-pos1.cl : Tests all the valid and legal syntax supported in Cool.
test-neg1.cl : Parser recovers from an erroneous single let statement and moves on to the block.
test-neg2.cl : Parser recovers from an error in a let statement that expects multiple bindings but only gets 1. And
               moves on to parsing block of expressions.
test-neg3.cl : Parser recovers from error in let statement and parses the next let statement. Nested Let
test-neg4.cl : Parser recovers from an error in let binding and moves on to the next let binding.
test-neg5.cl : Parser recovers from error in a properly terminated feature
test-neg6.cl : Parser recovers from an error in formal list by moving on to the next feature
test-neg7.cl : "three token problem" Two consecutive errors pair to be reported once when the first error is not
               followed by atleast 3 valid tokens
test-neg8.cl : Parser recovers from error in block
test-neg9.cl : Parser reports two consecutive error lines as long as 3 valid tokens follow the 1st erroneous expression
test-neg10.cl : Parser reports non associative error
test-neg11.cl : Parser recovers from errors in features
test-neg12.cl : Paser recovers from typo in inherits
test-neg13.cl : Paser recovers from typo in class (with inheritance)
test-neg14.cl : Paser recovers from typo in class (without inheritance)
test-neg15.cl : Parser recovers from typo in "let"

- Positive test cases
test-pos1.cl :
    1. Class definitions with single feature and multiple features (including attributes(with and without initialization) and methods)
    2. Class definition with and without inheritance
    3. Features with formal list
    4. Some arithmetic operations
    5. Implicitly testing blocks
    6. Assignment expression
test-pos2.cl :
    1. Block expressions
    2. Assignment expression
    3. if else then expression
    4. accessing methods of parent classes that have been hidden by redefinitions in child classes (@TYPE)
test-pos3.cl :
    1. Block Expressions
    2. Nested Let expressions
    3. Expressions in parentheses
    4. While loop
    5. method dispatching (line 26)
test-pos4.cl :
    1. Case expression
    2. Multiple formals in method.
test-pos5.cl :
    1. Multiple let bindings
    2. new TYPE
    3. If else then expression
    4. NOT operator
test-pos6.cl :
    1. isvoid expression
    2. new Object
    3. Method dispatching

The parser has been extensively tested with test cases described above as well as all the available examples and covers
all the valid syntax from the reference manual as well as tries to handle errors and recover. All the shift reduce
conflicts have been resolved by redefining the grammar without compromising the valid input strings. Hence I believe
that the parser is correct and robust.